# 实现分页机制

> 原文：[https://os.phil-opp.com/double-fault-exceptions/](https://os.phil-opp.com/double-fault-exceptions/)
>
> 原作者： [@Philipp Oppermann](https://github.com/phil-opp) 
>
> 译者：[倪广野](https://github.com/niguangye)

本文演示了在内核中实现分页机制的方法。它首先探究了让内核可以访问页表对应物理内存帧的不同技术，然后讨论了其中的优缺点，最后实现了一个地址转换函数和创建新映射的函数。

这个博客在 [GitHub](https://github.com/phil-opp/blog_os) 上开源。如果你遇到问题或困难，请到那里提 issue 。或者你也可以在博客的最下方留言。你可以在 [`post-09`](https://github.com/phil-opp/blog_os/tree/post-09) 分支找到这篇文章的完整源码。

## 简介

[上篇文章](https://os.phil-opp.com/paging-introduction/)给出了内存分页机制的概念解释——通过与分段机制的对比，引出了分页机制的缘由，解释了分页机制和页表的工作原理，然后介绍了 `x86_64` 的4级页表设计。我们发现 *bootloader* 早已建立了内核的页表体系，这表明我们的内核早已循行在虚拟地址上。分页机制改进了内核的内存安全性——非法内存访问将会触发缺页异常，而不是随意修改物理内存。

因为页表保存在物理内存，而内核运行在虚拟地址上，上篇文章遗留了一个问题： [内核无法直接访问页表](https://os.phil-opp.com/paging-introduction/#accessing-the-page-tables)。本文将从这个问题开始，然后介绍让内核可以直接访问页表的不同方式。我们将会讨论不同方式的优缺点，并在此基础上决定采用哪种方式。

内核直接访问页表的方式需要来自 *bootloader* 的支持，所以我们会首先配置它。然后，为了转换虚拟地址到物理地址，我们会实现一个遍历页表体系的函数。最后，我们会学习到在页表中创建新映射和找到未使用的内存帧创建新页表的方法。

## 访问页表

内核访问页表并不像看起来那么容易。为了解决这个问题，让我们再次查看上篇文章讲述的4级页表体系：

![x86_64-page-table-translation](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/x86_64-page-table-translation.svg)

其中最重要的是，每个页表条目都直接保存了下一张表的物理地址。所以这些地址不再需要虚拟地址到物理地址的转换流程，这个流程会影响性能，更容易引起无休止的转换循环。

由于内核运行在虚拟地址之上，所以我们不能直接访问物理地址。例如，我们访问地址 `4 KiB`的时候，是在访问虚拟地址 `4 KiB`，而不是存储4级页表的物理地址 `4 KiB`。如果希望访问物理地址 `4 KiB`，我们只能通过映射到它的虚拟地址。

所以为例访问页表的物理内存帧，我们需要建立一个虚拟内存页到该物理内存帧的映射。有多种不同的方式可以创建允许我们任意访问页表物理内存帧的映射。

### 恒同映射

最简单的方案是恒同映射（*译注：物理地址和虚拟地址完全相同*）所有页表：

![identity-mapped-page-tables](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/identity-mapped-page-tables.svg)

在这个例子中，我们可以看到大量恒同映射的页表内存帧。在这种方式下，页表的物理地址也是合法的虚拟地址，所以我们可以轻易地访问从 *CR3* 寄存器开始的所有等级的页表。

然而，这种方式弄乱了虚拟地址空间，也让找到大尺寸的连续内存空间变得困难。现在，假如我们要在上图中开辟一个1000 *KiB* 大小的虚拟内存空间（例如为了内存映射一个文件）。我们不能在 `28 KiB` 的地方开始，因为它会和 `1004 KiB`位置处已经映射的页发生冲突。所以我们必须继续寻找，直到得到一块足够大的未映射区域，例如 `1008 KiB` 处。这种情况很像分段机制的碎片问题。

此外，这也让创建新页表变得更加困难，因为我们需要找到对应虚拟地址页没有被占用的物理帧。假如我们已经为内存映射文件分配了开始于 `1008 KiB` ，长度1000 *KiB* 的虚拟内存空间。那么我们就再也不能使用物理地址从 `1000 KiB` 到 `2008 KiB` 对应的内存帧了，因为我们做不到恒同映射它们。

### 固定偏移映射

为了避免弄乱虚拟地址空间，我们使用分散的内存空间去进行页表映射。也就是说不再恒同映射页表内存帧，而是在虚拟内存空间中加上一个固定的偏移。例如偏移10 *TiB*：

![page-tables-mapped-at-offset](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/page-tables-mapped-at-offset.svg)

通过将10 TiB - （10 TiB + 物理内存地址）范围内的虚拟内存专门用作页表映射，可以避免恒同映射带来的地址冲突问题。只有虚拟地址空间远远大于物理内存容量的情况下，才能分配虚拟地址空间如此大的一块区域。这并不是一个问题，因为 `x86_64`体系结构的 48 位寻址空间足足有 256 *TiB* 大小。

这个方法仍然存在不足：只要需要创建新的页表，我们就必须创建一个新的映射。同时，它不允许访问其它地址空间的页表，但是这恰恰在创建新进程的时候事关重大。（*译注：这两个缺点都是相对于**映射整个物理内存**这个方式来讲*）。

### 映射整个物理内存

映射整个物理内存而不是仅仅映射页表的物理帧，可以解决这些问题：

![map-complete-physical-memory](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/map-complete-physical-memory.svg)

这个方式允许内核任意访问物理内存，包括其它地址空间的页表内存帧。分配的虚拟内存范围和以前相同，区别在于它已不再包含未映射的页。

这个方式的缺点在于需要额外的页表去保存其它物理内存的映射。这些页表需要被保存在某些地方，它们会占用一块物理内存——这可能会在小内存设备上造成问题。

在 `x86_64` 体系结构中，我们可以使用 2 *MiB* 大小的大页（ [huge pages](https://en.wikipedia.org/wiki/Page_(computer_memory)#Multiple_page_sizes)）保存这些映射，而不是4 *KiB* 页。这种方式，映射32 *GiB* 物理内存只需要132 *KiB*大小的页表，因为只需要一个3级页表和32个2级页表。因为大页使用更少的旁路转换缓冲（ *translation lookaside buffer ，TLB*，*译注：一译快表*)条目，所以更方便缓存。

### 临时映射

对于小内存的设备，我们可以只在需要访问页表的时候建立临时映射。仅仅需要一个恒同映射的1级页表就可以建立临时映射：

![temporarily-mapped-page-tables](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/temporarily-mapped-page-tables.svg)

图片中的1级页表控制着虚拟地址空间最开始的2 *MiB* 地址。这是因为不论 *CR3* 寄存器，还是四级、三级、二级页表的第一个条目都可以访问到它。索引为 `8` 的条目映射着 `32 KiB` 处的虚拟页和 `32 KiB` 处的物理帧。因此1级页表恒同映射着它自己。图片中的 `32 KiB` 处的水平箭头代表着这个恒同映射。

通过写入恒同映射的1级页表，内核可以建立511条临时映射（512减去恒同映射1级页表的这一条目）。在上面的例子中，内核建立了两个临时映射：

- 通过映射1级页表的第0条目到 `24 KiB` 处的物理帧，它创建了 `0 KiB` 处的虚拟页到2级页表对应的内存帧的临时映射。虚线箭头正代表这一映射。
- 通过映射1级页表的第9条目到 `4 KiB` 处的物理帧，它创建了 `36 KiB` 处的虚拟页到4级页表对应的内存帧的临时映射。虚线箭头正代表这一映射。

现在，内核可以通过写入 `0 KiB` 处的虚拟页访问2级页表，写入 `36 KiB` 处的虚拟页访问4级页表。

通过临时映射访问任意页表的过程如下所述：

- 查找恒同映射的1级页表的空闲条目。
- 映射该条目到希望访问的页表的物理内存帧。
- 通过映射到这个条目的虚拟内存页访问目的内存帧。
- 设置条目状态为未使用，从而移除临时映射。

这个方式重复使用512条虚拟内存页去创建映射，因此只需要4 *KiB* 物理内存。它的缺点是过于复杂，尤其是当新映射需要多个页表级别的修改时，这意味着我们需要重复多次上述流程。

### 递归页表

另一种有趣的方式是递归映射页表，它不需要额外的页表。这种方式背后的逻辑是映射一部分4级页表的条目到4级页表本身。通过这种方式，我们可以有效地分配一部分虚拟地址空间，并映射当前和将来的页表内存帧到这个空间。

让我们通过一个例子来理解它的工作原理：

![recursive-page-table](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/recursive-page-table.png)

和文章开头的例子唯一的不同是位于4级页表 `511` 索引处的条目，它映射到 `4 KiB` 处的物理内存帧——也就是4级页表本身。

根据这个条目，CPU在地址转换过程中会再次访问到4级页表而不是3级页表。这个过程就像递归函数调用自身一样，所以这个页表被称作**递归页表**（ *recursive page table*）。由于CPU假定4级页表的每个条目都指向3级页表，所以它把4级页表当作3级页表一样对待。CPU能正常工作完全是因为`x86_64`体系上的所有页表结构都一致。

通过在实际转换过程开始之前，一次或多次访问递归条目，我们可以有效地减少CPU页表级数。举个例子，如果我们访问一次递归条目，然后继续执行到3级页表，CPU会认为3级页表是一个2级页表。继续执行下去，CPU会把2级页表当作1级页表对待，然后把1级页表当作映射的内存帧。这意味着，我们可以读写一级页表，因为CPU认为这是映射的内存帧。下面的图表说明了5个转换步骤：

![recursive-page-table-access-level-1](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/recursive-page-table-access-level-1.png)

类似的，我们可以在地址转换过程之前，访问递归条目两次，从而把访问的页表级数降低到2：

![recursive-page-table-access-level-2](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/recursive-page-table-access-level-2.png)

让我们一步一步做下去：首先，CU访问4级页表的递归条目，并认为自己访问了3级页表。然后，它再次访问4级页表的递归条目，并认为自己访问了2级页表。当然，CPU实际上仍然处在4级页表。CPU现在访问了一个不同的条目，它访问到了3级页表，当时认为自己已经到达了1级页表。所以，当下一个条目指向2级页表时，CPU认为该条目已经指向了映射的内存帧，这允许我们读写2级页表。

使用同样的方式访问3级和4级页表。为了访问3级页表，我们跟进递归条目3次，欺骗CPU认为自己已经在1级页表上了。然后，跟进另一个条目到达3级页表，CPU会把它当作映射的内存帧。为了访问4级页表自身，我们跟进递归条目4次直到CPU把4级页表当作映射的内存帧（下图中的蓝色箭头）。

![recursive-page-table-access-level-3](https://markdown-ngy.oss-cn-beijing.aliyuncs.com/recursive-page-table-access-level-3.png)

这些概念可能会让你头大，但是它们在实际中运行地非常好。

下一节中，我们解释了如何构建跟进递归条目一次或多次的虚拟地址。我们不会使用递归分页技术，所以你不需要阅读它。但是如果你对它感兴趣，就展开“`地址计算`”部分去阅读它。

### 地址计算



递归分页是一项显示了页表中的单一映射强大威力的有趣技术。它实现起来相当简单，并且只需要少量的步骤（仅仅一个递归条目），所以它对于第一次实现分页机制的尝试是一个优秀的选择。

但是，它依然存在部分缺陷：

- 它占用了大量的虚拟内存（512 *GiB*）。这对于48位的寻址空间并不是一个问题，但是却可能带来较差的缓存性能。
- 它肯定只允许访问当前活跃的地址空间。通过修改递归条目访问其它地址空间是可行的，但是切换回来需要临时映射。我们在[*Remap The Kernel*](https://os.phil-opp.com/remap-the-kernel/#overview) 中解释了这一过程。
- 它严重依赖 `x86` 体系的页表结构，并且在其它架构体系中可能不能正常工作。

### 启动信息



### entry_point宏

## 实现

### 访问页表

### 转换地址

### 使用偏移页表

### 创建新映射

### 分配内存帧

## 总结

## 接下来?

